require(RColorBrewer)
require(classInt)
require(ggrepel)
require(scales)
require(rgdal)
require(ggspatial)
require(extrafont)
require(showtext)
font_add_google("Noto Sans KR", "notosanskr")
cols<-c("G1"="#ca0020","G2"="#f4a582","G3"="#92c5de","G4"="#0571b0")
map.dtw.h04<-ggplot()+
geom_sf(data=ltla,aes(fill=CLU),linewidth=0.2,colour="gray60")+
#scale_fill_brewer(palette = "OrRd",labels=c("Not Sig.","Hot spot","Cold spot"))
scale_fill_manual(values=cols,drop=FALSE)+
theme_bw()+
theme(text=element_text(size=rel(6), family="notosanskr",),
plot.title = element_text(size =rel(5), family="notosanskr",
face = "bold"),
legend.title=element_text(size =rel(5), family="notosanskr",
face = "bold"),
legend.text=element_text(size =rel(5), family="notosanskr"),
legend.position= "bottom")+
annotation_scale(location = "br", height = unit(0.5, "cm")) +
annotation_north_arrow(location = "tl",
style = north_arrow_nautical,
height = unit(2, "cm"),
width = unit(2, "cm"))+
labs(fill="Cluster",x=NULL,y=NULL)+
geom_sf(data=eng.la,fill=NA,color="black",linewidth=0.3,
show.legend=FALSE)+
geom_label_repel(data=la.coords, aes(X, Y, label = NAME),
colour = "Black",size=rel(15),
family="notosanskr",
fontface="bold",
alpha=.7,
segment.color = 'gray50')
ggsave("map.dtw.h04.per.png", width=200, height=200, scale=2,
units = "mm", dpi = 300, bg = "white")
#ggsave("map.dtw.h04.per.png", map.dtw.h04,width=400, height=400, units = "mm", dpi = 300, bg = "white")
levels(ltla$CLU)
#levels(ltla$CLU)<-c("2","1","3","4")
#ltla$CLU <- ordered(ltla$CLU, levels = c("2", "1", "3","4"))
indep.data<-readRDS(paste0(data.path,"indep.var.rda"))
require(glmnet)
ltla<-ltla[order(ltla$LTLA19CD),]
indep.data<-indep.data[order(indep.data$LTLA19CD),]
std.indep.data<-as.data.frame(scale(indep.data[3:38]))
std.indep.data[is.na(std.indep.data)]<-0
##make dummy variable
region.cat<-st_drop_geometry(ltla) %>% dplyr::select(LTLA19CD,REG_NM,CLU) %>% dplyr::ungroup()
region.cat$REG_NM<-factor(region.cat$REG_NM)
region.cat$bi.01[region.cat$REG_NM=="North East"]<-1
region.cat$bi.02[region.cat$REG_NM=="North West"]<-1
region.cat$bi.03[region.cat$REG_NM=="Yorkshire and The Humber"]<-1
region.cat$bi.04[region.cat$REG_NM=="East Midlands"]<-1
region.cat$bi.05[region.cat$REG_NM=="West Midlands"]<-1
region.cat$bi.06[region.cat$REG_NM=="East of England"]<-1
region.cat$bi.07[region.cat$REG_NM=="London"]<-1
region.cat$bi.08[region.cat$REG_NM=="South East"]<-1
region.cat$bi.09[region.cat$REG_NM=="South West"]<-1
levels(region.cat$REG_NM)<-c("4","6","7","1","2","8","9","5","3")
region.cat$cat<-as.numeric(region.cat$REG_NM)
region.cat[is.na(region.cat)]<-0
##Scale the independent variable
y=as.matrix(ltla$CLU)
std.indep.data.cat<-cbind(std.indep.data,region.cat %>% select(cat()))
std.indep.data.bin<-cbind(std.indep.data,region.cat %>% select(-LTLA19CD,-REG_NM,-CLU))
x=as.matrix(std.indep.data)
x.cat=as.matrix(std.indep.data.cat)
x.bin=as.matrix(std.indep.data.bin)
##LASSO fit
lasso.fit<-glmnet(x,y,family = "multinomial", alpha=1, standardise=TRUE, nfolds=10) #trace.it = TRUE)
plot(lasso.fit, xvar = "lambda", label = TRUE, type.coef = "2norm")
#Graphical parameters showing the ℓ2-norm in one figur
best_lambda_lasso<-min(lasso.fit$lambda)
lasso.cvfit <- cv.glmnet(x, y, family = "multinomial", alpha=1, standardise=TRUE, type.multinomial = "ungrouped", type.measure="class",nfolds=10)
plot(lasso.cvfit)
coef(lasso.cvfit, s = "lambda.min")
y_pred_coeff <- predict(lasso.cvfit, s="lambda.min", type="coefficients")
y_multi_pred_class <- as.numeric(predict(lasso.fit, newx = x, type = "class",s=lasso.cvfit$lambda.min))
xtabs(~ y_multi_pred_class + y)
mean(y == y_multi_pred_class) #68.6% accurancy
sqrt(lasso.cvfit$cvm[lasso.cvfit$lambda == lasso.cvfit$lambda.min])
sqrt(lasso.cvfit$cvm[lasso.cvfit$lambda == lasso.cvfit$lambda.1se])
##Get AIC and BIC value for MNL Lasso model
glmnet_cv_aicc <- function(fit, lambda = 'lambda.min'){
whlm <- which(fit$lambda == fit[[lambda]])
with(fit$glmnet.fit,
{
tLL <- nulldev - nulldev * (1 - dev.ratio)[whlm]
k <- df[whlm]
n <- nobs
return(list('AICc' = - tLL + 2 * k + 2 * k * (k + 1) / (n - k - 1),
'BIC' = log(n) * k - tLL))
})
}
print(glmnet_cv_aicc(lasso.cvfit))
require(ISLR)
require(caret)
input.data<-cbind(indep.data[c(1:2)],std.indep.data)
input.data<-left_join(input.data,mob.cluster,by="LTLA19CD")
cv_5 = trainControl(method = "cv", number = 5)
def_elnet=train(CLU~.,data=input.data[c(3:39)],method="glmnet",trControl=cv_5,trueLength=10)
def_elnet
get_best_result = function(caret_fit) {
best = which(rownames(caret_fit$results) == rownames(caret_fit$bestTune))
best_result = caret_fit$results[best, ]
rownames(best_result) = NULL
best_result
}
get_best_result(def_elnet) #alpha=1, accurancy = 56.8%
uk.ep.data<-readRDS(paste0(data.path,"uk.ep.data.rda"))
en.ep.data<-subset(uk.ep.data,grepl("E0",LTLA19CD))
en.ep.data<-en.ep.data[order(en.ep.data$date,en.ep.data$LTLA19CD),]
ltla.pop<-read.csv(paste0(data.path,"ltla.pop.per.ep.data.csv"))
ltla.pop<-ltla.pop[c(2,3,4)]
en.ep.data<-left_join(en.ep.data,ltla.pop,by=c("LTLA19CD","LTLA19NM"))
en.ep.data$daily.cases.per<-en.ep.data$daily.cases/(en.ep.data$LTLA.POP/100000)
en.ep.data$daily.deaths.per<-en.ep.data$daily.deaths/(en.ep.data$LTLA.POP/100000)
en.ep.data<-subset(en.ep.data,date>="2020-01-30" & date<"2020-07-07")
en.ep.data[is.na(en.ep.data)]<-0
require(lubridate)
require(plyr)
en.ep.data$wk<-week(en.ep.data$date)
wk.en.ep.data<-ddply(en.ep.data,.(LTLA19CD,LTLA19NM,wk),summarise,weekly.avg.cases=mean(daily.cases,na.rm=TRUE),
weekly.avg.deaths=mean(daily.deaths,na.rm=TRUE),
weekly.avg.cases.per=mean(daily.cases.per,na.rm=TRUE),
weekly.avg.deaths.per=mean(daily.deaths.per,na.rm=TRUE))
#Cumulative infection rates from 30 January 2020 to 23 March 2020
before.en.ep.data<-subset(en.ep.data,date>="2020-01-30" & date<"2020-03-23")
before.en.ep.data<-ddply(before.en.ep.data,.(LTLA19CD,LTLA19NM),summarise,total.cases=sum(daily.cases), total.deaths=sum(daily.deaths))
before.en.ep.data<-left_join(before.en.ep.data,ltla.pop,by=c("LTLA19CD","LTLA19NM"))
before.en.ep.data$cum.infection.rates<-before.en.ep.data$total.cases/(before.en.ep.data$LTLA.POP/100000)
before.en.ep.data$cum.mortality.rates<-before.en.ep.data$total.deaths/(before.en.ep.data$LTLA.POP/100000)
input.eigen.before.en.ep.data<-left_join(ltla,before.en.ep.data,by=c("LTLA19CD","LTLA19NM"))
cum.infection.rates.by.cluster<- ggplot(data=input.eigen.before.en.ep.data,aes(x=CLU, y=cum.infection.rates,fill=CLU))+  geom_boxplot(alpha=0.8) + labs(x="Latent temporal clusters by the changes in mobility ",y="Cumulative COVID-19 infection rates per 100k resident population before 1st lockdown",fill="Cluster",face="bold")
cum.infection.rates.by.cluster
#ggsave("cum.infection.rates.by.cluster.before.lockdown.png", cum.infection.rates.by.cluster,width=400, height=400, units = "mm", dpi = 300, bg = "white")
cum.mortality.rates.by.cluster<- ggplot(data=input.eigen.before.en.ep.data,aes(x=CLU, y=cum.mortality.rates,fill=CLU))+  geom_boxplot(alpha=0.8)+labs(x="Latent temporal clusters by the changes in mobility ",y="Cumulative COVID-19 mortality rates per 100k resident population before 1st lockdown",fill="Cluster",face="bold")
cum.mortality.rates.by.cluster
#ggsave("cum.mortality.rates.by.cluster.before.lockdown.png", cum.mortality.rates.by.cluster,width=400, height=400, units = "mm", dpi = 300, bg = "white")
ndep.data<-indep.data[order(indep.data$LTLA19CD),]
indep.data.update<-left_join(indep.data,input.eigen.before.en.ep.data[c(1:2,11:12)],by=c("LTLA19CD","LTLA19NM"))
std.indep.data.update<-as.data.frame(as.data.frame(scale(indep.data.update[c(3:40)])))
require(BBmisc)
std.indep.data.update<-normalize(indep.data.update[c(3:40)],method="standardize",range=c(0,1),margin=1L,on.constant="quiet")
std.indep.data.update[is.na(std.indep.data.update)]<-0
region.cat$cat<-factor(region.cat$cat)
std.indep.data.cat<-cbind(std.indep.data.update,region.cat %>% select(cat))
std.indep.data.bin<-cbind(std.indep.data.update,region.cat %>% select(-LTLA19CD,-REG_NM,-CLU,-cat))
##Scale the independent variable
y=as.matrix(ltla$CLU)
x.update=as.matrix(std.indep.data.update)
x.update.cat=as.matrix(std.indep.data.cat)
x.update.bin=as.matrix(std.indep.data.bin)
?glmnet
##Model fitting #1 ref
lasso.fit.re<-glmnet(x.update,y,family = "multinomial", alpha=1, standardize=TRUE, type.multinomial = "ungrouped", nfolds=10) #trace.it = TRUE)
plot(lasso.fit.re, xvar = "lambda", label = TRUE, type.coef = "2norm")
#Graphical parameters showing the ℓ2-norm in one figur
best_lambda_lasso<-min(lasso.fit.re$lambda)
lasso.cvfit.re <- cv.glmnet(x.update.bin, y, family = "multinomial", alpha=1, standardize =TRUE, type.multinomial = "ungrouped", type.measure="mse",nfolds=10)
plot(lasso.cvfit.re)
coef.g1<-data.frame(name = coef(lasso.cvfit.re, s = "lambda.min")$'G1'@Dimnames[[1]][coef(lasso.cvfit.re, s = "lambda.min")$'G1'@i + 1], coefficient = coef(lasso.cvfit.re, s = "lambda.min")$'G1'@x,group="G1")
coef.g2<-data.frame(name = coef(lasso.cvfit.re, s = "lambda.min")$'G2'@Dimnames[[1]][coef(lasso.cvfit.re, s = "lambda.min")$'G2'@i + 1], coefficient = coef(lasso.cvfit.re, s = "lambda.min")$'G2'@x,group="G2")
coef.g3<-data.frame(name = coef(lasso.cvfit.re, s = "lambda.min")$'G3'@Dimnames[[1]][coef(lasso.cvfit.re, s = "lambda.min")$'G3'@i + 1], coefficient = coef(lasso.cvfit.re, s = "lambda.min")$'G3'@x,group="G3")
coef.g4<-data.frame(name = coef(lasso.cvfit.re, s = "lambda.min")$'G4'@Dimnames[[1]][coef(lasso.cvfit.re, s = "lambda.min")$'G4'@i + 1], coefficient = coef(lasso.cvfit.re, s = "lambda.min")$'G4'@x,group="G4")
coef.all<-union_all(coef.g1,coef.g2);coef.all<-union_all(coef.all,coef.g3);coef.all<-union_all(coef.all,coef.g4)
coef.all$name<-factor(coef.all$name)
levels(coef.all$name)
##Model fitting #1 ref
lasso.fit.re<-glmnet(x.update,y,family = "multinomial", alpha=1, standardize=TRUE, type.multinomial = "ungrouped", nfolds=10) #trace.it = TRUE)
plot(lasso.fit.re, xvar = "lambda", label = TRUE, type.coef = "2norm")
#Graphical parameters showing the ℓ2-norm in one figur
best_lambda_lasso<-min(lasso.fit.re$lambda)
lasso.cvfit.re <- cv.glmnet(x.update, y, family = "multinomial", alpha=1, standardize =TRUE, type.multinomial = "ungrouped", type.measure="mse",nfolds=10)
plot(lasso.cvfit.re)
coef.g1<-data.frame(name = coef(lasso.cvfit.re, s = "lambda.min")$'G1'@Dimnames[[1]][coef(lasso.cvfit.re, s = "lambda.min")$'G1'@i + 1], coefficient = coef(lasso.cvfit.re, s = "lambda.min")$'G1'@x,group="G1")
coef.g2<-data.frame(name = coef(lasso.cvfit.re, s = "lambda.min")$'G2'@Dimnames[[1]][coef(lasso.cvfit.re, s = "lambda.min")$'G2'@i + 1], coefficient = coef(lasso.cvfit.re, s = "lambda.min")$'G2'@x,group="G2")
coef.g3<-data.frame(name = coef(lasso.cvfit.re, s = "lambda.min")$'G3'@Dimnames[[1]][coef(lasso.cvfit.re, s = "lambda.min")$'G3'@i + 1], coefficient = coef(lasso.cvfit.re, s = "lambda.min")$'G3'@x,group="G3")
coef.g4<-data.frame(name = coef(lasso.cvfit.re, s = "lambda.min")$'G4'@Dimnames[[1]][coef(lasso.cvfit.re, s = "lambda.min")$'G4'@i + 1], coefficient = coef(lasso.cvfit.re, s = "lambda.min")$'G4'@x,group="G4")
coef.all<-union_all(coef.g1,coef.g2);coef.all<-union_all(coef.all,coef.g3);coef.all<-union_all(coef.all,coef.g4)
coef.all$name<-factor(coef.all$name)
levels(coef.all$name)
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE
)
Sys.setlocale(locale="English_United Kingdom")
setwd("d:/WORKSPACE/GIT/covid19-eng-lockdown/process/")
data.path<-"d:/WORKSPACE/GIT/covid19-eng-lockdown/data/"
require(sf)
require(rgdal)
require(dplyr)
ltla<-st_read(paste0(data.path,"EN_LTLA_FOR_EP.shp"))
eng.la<-st_read(paste0(data.path,"ENGLAND_REGIONS.shp"))
eng.la.coord <- sf::st_point_on_surface(eng.la)
la.coords <- as.data.frame(sf::st_coordinates(eng.la.coord))
la.coords$NAME <- eng.la.coord$RGN11NM
mob.cluster<-readRDS(paste0(data.path,"mobility.temporal.cluster.rda"))
mob.cluster$CLU<-as.factor(mob.cluster$CLU)
ltla<-left_join(ltla,mob.cluster,by="LTLA19CD")
levels(ltla$CLU)<-c("G4","G3","G1","G2")
ltla$CLU<-factor(ltla$CLU,levels=c("G1","G2","G3","G4"))
require(ggplot2)
require(RColorBrewer)
require(classInt)
require(ggrepel)
require(scales)
require(rgdal)
require(ggspatial)
require(extrafont)
require(showtext)
font_add_google("Noto Sans KR", "notosanskr")
cols<-c("G1"="#ca0020","G2"="#f4a582","G3"="#92c5de","G4"="#0571b0")
map.dtw.h04<-ggplot()+
geom_sf(data=ltla,aes(fill=CLU),linewidth=0.2,colour="gray60")+
#scale_fill_brewer(palette = "OrRd",labels=c("Not Sig.","Hot spot","Cold spot"))
scale_fill_manual(values=cols,drop=FALSE)+
theme_bw()+
theme(text=element_text(size=rel(6), family="notosanskr",),
plot.title = element_text(size =rel(5), family="notosanskr",
face = "bold"),
legend.title=element_text(size =rel(5), family="notosanskr",
face = "bold"),
legend.text=element_text(size =rel(5), family="notosanskr"),
legend.position= "bottom")+
annotation_scale(location = "br", height = unit(0.5, "cm")) +
annotation_north_arrow(location = "tl",
style = north_arrow_nautical,
height = unit(2, "cm"),
width = unit(2, "cm"))+
labs(fill="Cluster",x=NULL,y=NULL)+
geom_sf(data=eng.la,fill=NA,color="black",linewidth=0.3,
show.legend=FALSE)+
geom_label_repel(data=la.coords, aes(X, Y, label = NAME),
colour = "Black",size=rel(15),
family="notosanskr",
fontface="bold",
alpha=.7,
segment.color = 'gray50')
ggsave("map.dtw.h04.per.png", width=200, height=200, scale=2,
units = "mm", dpi = 300, bg = "white")
#ggsave("map.dtw.h04.per.png", map.dtw.h04,width=400, height=400, units = "mm", dpi = 300, bg = "white")
levels(ltla$CLU)
#levels(ltla$CLU)<-c("2","1","3","4")
#ltla$CLU <- ordered(ltla$CLU, levels = c("2", "1", "3","4"))
indep.data<-readRDS(paste0(data.path,"indep.var.rda"))
require(glmnet)
ltla<-ltla[order(ltla$LTLA19CD),]
indep.data<-indep.data[order(indep.data$LTLA19CD),]
std.indep.data<-as.data.frame(scale(indep.data[3:38]))
std.indep.data[is.na(std.indep.data)]<-0
##make dummy variable
region.cat<-st_drop_geometry(ltla) %>% dplyr::select(LTLA19CD,REG_NM,CLU) %>% dplyr::ungroup()
region.cat$REG_NM<-factor(region.cat$REG_NM)
region.cat$bi.01[region.cat$REG_NM=="North East"]<-1
region.cat$bi.02[region.cat$REG_NM=="North West"]<-1
region.cat$bi.03[region.cat$REG_NM=="Yorkshire and The Humber"]<-1
region.cat$bi.04[region.cat$REG_NM=="East Midlands"]<-1
region.cat$bi.05[region.cat$REG_NM=="West Midlands"]<-1
region.cat$bi.06[region.cat$REG_NM=="East of England"]<-1
region.cat$bi.07[region.cat$REG_NM=="London"]<-1
region.cat$bi.08[region.cat$REG_NM=="South East"]<-1
region.cat$bi.09[region.cat$REG_NM=="South West"]<-1
levels(region.cat$REG_NM)<-c("4","6","7","1","2","8","9","5","3")
region.cat$cat<-as.numeric(region.cat$REG_NM)
region.cat[is.na(region.cat)]<-0
##Scale the independent variable
y=as.matrix(ltla$CLU)
std.indep.data.cat<-cbind(std.indep.data,region.cat %>% select(cat()))
std.indep.data.bin<-cbind(std.indep.data,region.cat %>% select(-LTLA19CD,-REG_NM,-CLU))
x=as.matrix(std.indep.data)
x.cat=as.matrix(std.indep.data.cat)
x.bin=as.matrix(std.indep.data.bin)
##LASSO fit
lasso.fit<-glmnet(x,y,family = "multinomial", alpha=1, standardise=TRUE, nfolds=10) #trace.it = TRUE)
plot(lasso.fit, xvar = "lambda", label = TRUE, type.coef = "2norm")
#Graphical parameters showing the ℓ2-norm in one figur
best_lambda_lasso<-min(lasso.fit$lambda)
lasso.cvfit <- cv.glmnet(x, y, family = "multinomial", alpha=1, standardise=TRUE, type.multinomial = "ungrouped", type.measure="class",nfolds=10)
plot(lasso.cvfit)
coef(lasso.cvfit, s = "lambda.min")
y_pred_coeff <- predict(lasso.cvfit, s="lambda.min", type="coefficients")
y_multi_pred_class <- as.numeric(predict(lasso.fit, newx = x, type = "class",s=lasso.cvfit$lambda.min))
xtabs(~ y_multi_pred_class + y)
mean(y == y_multi_pred_class) #68.6% accurancy
sqrt(lasso.cvfit$cvm[lasso.cvfit$lambda == lasso.cvfit$lambda.min])
sqrt(lasso.cvfit$cvm[lasso.cvfit$lambda == lasso.cvfit$lambda.1se])
##Get AIC and BIC value for MNL Lasso model
glmnet_cv_aicc <- function(fit, lambda = 'lambda.min'){
whlm <- which(fit$lambda == fit[[lambda]])
with(fit$glmnet.fit,
{
tLL <- nulldev - nulldev * (1 - dev.ratio)[whlm]
k <- df[whlm]
n <- nobs
return(list('AICc' = - tLL + 2 * k + 2 * k * (k + 1) / (n - k - 1),
'BIC' = log(n) * k - tLL))
})
}
print(glmnet_cv_aicc(lasso.cvfit))
require(ISLR)
require(caret)
input.data<-cbind(indep.data[c(1:2)],std.indep.data)
input.data<-left_join(input.data,mob.cluster,by="LTLA19CD")
cv_5 = trainControl(method = "cv", number = 5)
def_elnet=train(CLU~.,data=input.data[c(3:39)],method="glmnet",trControl=cv_5,trueLength=10)
def_elnet
get_best_result = function(caret_fit) {
best = which(rownames(caret_fit$results) == rownames(caret_fit$bestTune))
best_result = caret_fit$results[best, ]
rownames(best_result) = NULL
best_result
}
get_best_result(def_elnet) #alpha=1, accurancy = 56.8%
uk.ep.data<-readRDS(paste0(data.path,"uk.ep.data.rda"))
en.ep.data<-subset(uk.ep.data,grepl("E0",LTLA19CD))
en.ep.data<-en.ep.data[order(en.ep.data$date,en.ep.data$LTLA19CD),]
ltla.pop<-read.csv(paste0(data.path,"ltla.pop.per.ep.data.csv"))
ltla.pop<-ltla.pop[c(2,3,4)]
en.ep.data<-left_join(en.ep.data,ltla.pop,by=c("LTLA19CD","LTLA19NM"))
en.ep.data$daily.cases.per<-en.ep.data$daily.cases/(en.ep.data$LTLA.POP/100000)
en.ep.data$daily.deaths.per<-en.ep.data$daily.deaths/(en.ep.data$LTLA.POP/100000)
en.ep.data<-subset(en.ep.data,date>="2020-01-30" & date<"2020-07-07")
en.ep.data[is.na(en.ep.data)]<-0
require(lubridate)
require(plyr)
en.ep.data$wk<-week(en.ep.data$date)
wk.en.ep.data<-ddply(en.ep.data,.(LTLA19CD,LTLA19NM,wk),summarise,weekly.avg.cases=mean(daily.cases,na.rm=TRUE),
weekly.avg.deaths=mean(daily.deaths,na.rm=TRUE),
weekly.avg.cases.per=mean(daily.cases.per,na.rm=TRUE),
weekly.avg.deaths.per=mean(daily.deaths.per,na.rm=TRUE))
#Cumulative infection rates from 30 January 2020 to 23 March 2020
before.en.ep.data<-subset(en.ep.data,date>="2020-01-30" & date<"2020-03-23")
before.en.ep.data<-ddply(before.en.ep.data,.(LTLA19CD,LTLA19NM),summarise,total.cases=sum(daily.cases), total.deaths=sum(daily.deaths))
before.en.ep.data<-left_join(before.en.ep.data,ltla.pop,by=c("LTLA19CD","LTLA19NM"))
before.en.ep.data$cum.infection.rates<-before.en.ep.data$total.cases/(before.en.ep.data$LTLA.POP/100000)
before.en.ep.data$cum.mortality.rates<-before.en.ep.data$total.deaths/(before.en.ep.data$LTLA.POP/100000)
input.eigen.before.en.ep.data<-left_join(ltla,before.en.ep.data,by=c("LTLA19CD","LTLA19NM"))
cum.infection.rates.by.cluster<- ggplot(data=input.eigen.before.en.ep.data,aes(x=CLU, y=cum.infection.rates,fill=CLU))+  geom_boxplot(alpha=0.8) + labs(x="Latent temporal clusters by the changes in mobility ",y="Cumulative COVID-19 infection rates per 100k resident population before 1st lockdown",fill="Cluster",face="bold")
cum.infection.rates.by.cluster
#ggsave("cum.infection.rates.by.cluster.before.lockdown.png", cum.infection.rates.by.cluster,width=400, height=400, units = "mm", dpi = 300, bg = "white")
cum.mortality.rates.by.cluster<- ggplot(data=input.eigen.before.en.ep.data,aes(x=CLU, y=cum.mortality.rates,fill=CLU))+  geom_boxplot(alpha=0.8)+labs(x="Latent temporal clusters by the changes in mobility ",y="Cumulative COVID-19 mortality rates per 100k resident population before 1st lockdown",fill="Cluster",face="bold")
cum.mortality.rates.by.cluster
#ggsave("cum.mortality.rates.by.cluster.before.lockdown.png", cum.mortality.rates.by.cluster,width=400, height=400, units = "mm", dpi = 300, bg = "white")
##Get AIC and BIC value for MNL Lasso model
print(glmnet_cv_aicc(lasso.cvfit.re))
indep.data<-indep.data[order(indep.data$LTLA19CD),]
indep.data.update<-left_join(indep.data,input.eigen.before.en.ep.data[c(1:2,11:12)],by=c("LTLA19CD","LTLA19NM"))
std.indep.data.update<-as.data.frame(as.data.frame(scale(indep.data.update[c(3:40)])))
require(BBmisc)
std.indep.data.update<-normalize(indep.data.update[c(3:40)],method="standardize",range=c(0,1),margin=1L,on.constant="quiet")
std.indep.data.update[is.na(std.indep.data.update)]<-0
region.cat$cat<-factor(region.cat$cat)
std.indep.data.cat<-cbind(std.indep.data.update,region.cat %>% select(cat))
std.indep.data.bin<-cbind(std.indep.data.update,region.cat %>% select(-LTLA19CD,-REG_NM,-CLU,-cat))
##Scale the independent variable
y=as.matrix(ltla$CLU)
x.update=as.matrix(std.indep.data.update)
x.update.cat=as.matrix(std.indep.data.cat)
x.update.bin=as.matrix(std.indep.data.bin)
##Model fitting #1 ref
lasso.fit.re<-glmnet(x.update,y,family = "multinomial", alpha=1, standardize=TRUE, type.multinomial = "ungrouped", nfolds=10) #trace.it = TRUE)
plot(lasso.fit.re, xvar = "lambda", label = TRUE, type.coef = "2norm")
#Graphical parameters showing the ℓ2-norm in one figur
best_lambda_lasso<-min(lasso.fit.re$lambda)
lasso.cvfit.re <- cv.glmnet(x.update, y, family = "multinomial", alpha=1, standardize =TRUE, type.multinomial = "ungrouped", type.measure="mse",nfolds=10)
plot(lasso.cvfit.re)
coef.g1<-data.frame(name = coef(lasso.cvfit.re, s = "lambda.min")$'G1'@Dimnames[[1]][coef(lasso.cvfit.re, s = "lambda.min")$'G1'@i + 1], coefficient = coef(lasso.cvfit.re, s = "lambda.min")$'G1'@x,group="G1")
coef.g2<-data.frame(name = coef(lasso.cvfit.re, s = "lambda.min")$'G2'@Dimnames[[1]][coef(lasso.cvfit.re, s = "lambda.min")$'G2'@i + 1], coefficient = coef(lasso.cvfit.re, s = "lambda.min")$'G2'@x,group="G2")
coef.g3<-data.frame(name = coef(lasso.cvfit.re, s = "lambda.min")$'G3'@Dimnames[[1]][coef(lasso.cvfit.re, s = "lambda.min")$'G3'@i + 1], coefficient = coef(lasso.cvfit.re, s = "lambda.min")$'G3'@x,group="G3")
coef.g4<-data.frame(name = coef(lasso.cvfit.re, s = "lambda.min")$'G4'@Dimnames[[1]][coef(lasso.cvfit.re, s = "lambda.min")$'G4'@i + 1], coefficient = coef(lasso.cvfit.re, s = "lambda.min")$'G4'@x,group="G4")
coef.all<-union_all(coef.g1,coef.g2);coef.all<-union_all(coef.all,coef.g3);coef.all<-union_all(coef.all,coef.g4)
coef.all$name<-factor(coef.all$name)
levels(coef.all$name)<-c("Constant","North East","Yorkshire and the Humber","East Midlands","West Midlands",
"East of England","London","South West","Cum. COVID-19 infection rates","Cum. COVID-19 moratlity rates", "%African","%Caribbean","%Other Asian","Hospitals","%High income HHs","%Median income HHs","%Self-employed","%Social grade C1","%more than 3 bed rooms","HHs with 1 vehicle","HHs with more than 3 vehicles")
require(forcats)
coef.all$name2<-fct_relevel(coef.all$name,"Constant","North East","Yorkshire and the Humber","East Midlands","West Midlands",
"East of England","London","South West","%High income HHs","%Median income HHs","%Social grade C1","%more than 3 bed rooms","HHs with 1 vehicle","HHs with more than 3 vehicles","Hospitals","%Self-employed","Cum. COVID-19 infection rates","Cum. COVID-19 moratlity rates","%Other Asian","%African","%Caribbean")
write.csv(coef.all,"lasso.estimated.coefficients.13Jul2023.csv")
vip(lasso.fit.re, num_features=46 ,geom = "col", include_type=TRUE, lambda = "lambda.1se")
vip::vip(lasso.fit.re, num_features=46 ,geom = "col", include_type=TRUE, lambda = "lambda.1se")
lasso.fit.re
best_lambda_lasso<-min(lasso.cvfit.re$lambda.min)
plot.std.coefficient<- ggplot(data = coef.all) +
geom_col(aes(x = coefficient, y = forcats::fct_rev(factor(name2)), fill = {coefficient > 0})) +
scale_fill_manual(values=c("blue", "red")) +
theme_bw()+
ggtitle(expression(paste("Estimated coefficients"))) +
xlab("Std.Coef.")+ylab("Predictors")+
theme(axis.text.x = element_text(angle = 45, hjust = 1),
legend.position = "none") + facet_grid(~group)
plot.std.coefficient
plot.std.coefficient
ggsave("lasso.mnl.std.coefficient.re.13Jul2023.png",plot.std.coefficient,width=200, height=200, units = "mm", dpi = 300, bg = "white")
require(BBmisc)
std.indep.data.update<-normalize(indep.data.update[c(3:40)],method="standardize",range=c(0,1),margin=1L,on.constant="quiet")
std.indep.data.update[is.na(std.indep.data.update)]<-0
region.cat$cat<-factor(region.cat$cat)
std.indep.data.cat<-cbind(std.indep.data.update,region.cat %>% select(cat))
std.indep.data.bin<-cbind(std.indep.data.update,region.cat %>% select(-LTLA19CD,-REG_NM,-CLU,-cat))
##Scale the independent variable
y=as.matrix(ltla$CLU)
x.update=as.matrix(std.indep.data.update)
x.update.cat=as.matrix(std.indep.data.cat)
x.update.bin=as.matrix(std.indep.data.bin)
##Model fitting #1 ref
lasso.fit.re<-glmnet(x.update,y,family = "multinomial", alpha=1, standardize=TRUE, type.multinomial = "ungrouped", nfolds=10) #trace.it = TRUE)
plot(lasso.fit.re, xvar = "lambda", label = TRUE, type.coef = "2norm")
#Graphical parameters showing the ℓ2-norm in one figur
best_lambda_lasso<-min(lasso.fit.re$lambda)
lasso.cvfit.re <- cv.glmnet(x.update, y, family = "multinomial", alpha=1, standardize =TRUE, type.multinomial = "ungrouped", type.measure="mse",nfolds=10)
plot(lasso.cvfit.re)
lasso.cvfit.re
coef.g1<-data.frame(name = coef(lasso.cvfit.re, s = "lambda.min")$'G1'@Dimnames[[1]][coef(lasso.cvfit.re, s = "lambda.min")$'G1'@i + 1], coefficient = coef(lasso.cvfit.re, s = "lambda.min")$'G1'@x,group="G1")
coef.g2<-data.frame(name = coef(lasso.cvfit.re, s = "lambda.min")$'G2'@Dimnames[[1]][coef(lasso.cvfit.re, s = "lambda.min")$'G2'@i + 1], coefficient = coef(lasso.cvfit.re, s = "lambda.min")$'G2'@x,group="G2")
coef.g3<-data.frame(name = coef(lasso.cvfit.re, s = "lambda.min")$'G3'@Dimnames[[1]][coef(lasso.cvfit.re, s = "lambda.min")$'G3'@i + 1], coefficient = coef(lasso.cvfit.re, s = "lambda.min")$'G3'@x,group="G3")
coef.g4<-data.frame(name = coef(lasso.cvfit.re, s = "lambda.min")$'G4'@Dimnames[[1]][coef(lasso.cvfit.re, s = "lambda.min")$'G4'@i + 1], coefficient = coef(lasso.cvfit.re, s = "lambda.min")$'G4'@x,group="G4")
coef.all<-union_all(coef.g1,coef.g2);coef.all<-union_all(coef.all,coef.g3);coef.all<-union_all(coef.all,coef.g4)
coef.all$name<-factor(coef.all$name)
levels(coef.all$name)
y
plyr::count(y)
write.csv(coef.all,"lasso.estimated.coefficients.13Jul2023.csv")
vip::vip(lasso.fit.re, num_features=46 ,geom = "col", include_type=TRUE, lambda = "lambda.1se")
best_lambda_lasso<-min(lasso.cvfit.re$lambda.min)
plot.std.coefficient<- ggplot(data = coef.all) +
geom_col(aes(x = coefficient, y = forcats::fct_rev(factor(name2)), fill = {coefficient > 0})) +
scale_fill_manual(values=c("blue", "red")) +
theme_bw()+
ggtitle(expression(paste("Estimated coefficients"))) +
xlab("Std.Coef.")+ylab("Predictors")+
theme(axis.text.x = element_text(angle = 45, hjust = 1),
legend.position = "none") + facet_grid(~group)
plot.std.coefficient
ggsave("lasso.mnl.std.coefficient.re.13Jul2023.png",plot.std.coefficient,width=200, height=200, units = "mm", dpi = 300, bg = "white")
y_pred_coeff_update <- predict(lasso.cvfit.re, s="lambda.min", type="coefficients")
y_multi_pred_class_update <- as.numeric(predict(lasso.fit.re, newx = x.update.bin, type = "class",s=lasso.cvfit.re$lambda.min))
y_pred_coeff_update <- predict(lasso.cvfit.re, s="lambda.min", type="coefficients")
y_multi_pred_class_update <- as.numeric(predict(lasso.fit.re, newx = x.update.bin, type = "class",s=lasso.cvfit.re$lambda.min))
y_pred_coeff_update <- predict(lasso.cvfit.re, s="lambda.min", type="coefficients")
y_multi_pred_class_update <- as.numeric(predict(lasso.fit.re, newx = x.update, type = "class",s=lasso.cvfit.re$lambda.min))
xtabs(~ y_multi_pred_class_update + y)
mean(y == y_multi_pred_class_update) #68.6% accurancy
sqrt(lasso.cvfit.re$cvm[lasso.cvfit.re$lambda == lasso.cvfit.re$lambda.min])
sqrt(lasso.cvfit.re$cvm[lasso.cvfit.re$lambda == lasso.cvfit.re$lambda.1se])
##Get AIC and BIC value for MNL Lasso model
print(glmnet_cv_aicc(lasso.cvfit.re))
y_pred_coeff_update <- predict(lasso.cvfit.re, s="lambda.min", type="coefficients")
y_multi_pred_class_update <- predict(lasso.fit.re, newx = x.update, type = "class",s=lasso.cvfit.re$lambda.min)
xtabs(~ y_multi_pred_class_update + y)
mean(y == y_multi_pred_class_update) #68.6% accurancy
##Get AIC and BIC value for MNL Lasso model
print(glmnet_cv_aicc(lasso.cvfit.re))
best_lambda_lasso
re.lasso.cvfit <- cv.glmnet(x.update, y, family = "multinomial", alpha=1, standardise=TRUE, type.multinomial = "ungrouped", type.measure="class",nfolds=10)
plot(re.lasso.cvfit)
coef(re.lasso.cvfit, s = "lambda.min")
re.lasso.cvfit
plot.rank.features<- ggplot(data = rel.importance.trans) +
geom_col(aes(x = importance, y = forcats::fct_rev(factor(Feature2)), fill = {importance > 0})) +
#scale_fill_manual(values=c("blue", "red")) +
ggtitle(expression(paste("Ranking the features (0 to 1)"))) +
ylab("Feature importance")+
theme_bw()+
scale_fill_manual(values="gray40")+
theme(axis.text.x = element_text(angle = 45, hjust = 1),
legend.position = "none") + facet_grid(~group)
caret::getModelInfo("glmnet")$glmnet$varImp
varImp <- function(object, lambda = NULL, ...) {
## skipping a few lines
beta <- predict(object, s = lambda, type = "coef")
if(is.list(beta)) {
out <- do.call("cbind", lapply(beta, function(x) x[,1]))
out <- as.data.frame(out, stringsAsFactors = TRUE)
} else out <- data.frame(Overall = beta[,1])
out <- abs(out[rownames(out) != "(Intercept)",,drop = FALSE])
out
}
rel.importance<-varImp(lasso.cvfit.re, lambda = best_lambda_lasso,
scale=TRUE)
rel.importance$name<-dimnames(rel.importance)[[1]]
colnames(rel.importance)<-c("G1","G2","G3","G4","Feature")
require(reshape2)
rel.importance.trans<-melt(rel.importance,value.name="importance",value.var="Feature",variable.name="group")
rel.importance.trans$Feature<-as.factor(rel.importance.trans$Feature)
levels(rel.importance.trans$Feature)
rel.importance<-varImp(lasso.cvfit.re, lambda = best_lambda_lasso,
scale=TRUE)
rel.importance$name<-dimnames(rel.importance)[[1]]
colnames(rel.importance)<-c("G1","G2","G3","G4","Feature")
require(reshape2)
rel.importance.trans<-melt(rel.importance,value.name="importance",value.var="Feature",variable.name="group")
rel.importance.trans$Feature<-as.factor(rel.importance.trans$Feature)
levels(rel.importance.trans$Feature)
levels(rel.importance.trans$Feature)<-c("Cumulative COVID-19 infection rates","Cumulative COVID-19 mortality rates", "%African","%Bangladeshi","%Caribbean","%Chinese","%Indian","%Mixed","%Other ethnic group","%Other Asian","%Other Black","%Pakistani","%White","%Full-time worker", "%Bad heath" , "%Fair health", "%Good Health" , "Hospitals" , "%Low income HHs", "%High income HHs", "%Median income HHs", "Supermarkets","%No education","%Non-English speakers","Parks", "%Part-time worker","Residential population density", "%Self-employed", "%Social grade AB","%Social grade C1", "%Social Grade C2","%Social grade DE", "%Social rent", "%more than 3 beds","No vehicle in HHs", "1 vehicle in HHs","2 vehicles in HHs","more than 3 vehicles in HHs")
rel.importance.trans<-subset(rel.importance.trans,importance>0)
rel.importance.trans$Feature2<-fct_relevel(rel.importance.trans$Feature,"%Low income HHs","%Median income HHs","%High income HHs","%No education","%Non-English speakers", "%Social grade AB","%Social grade C1", "%Social Grade C2","%Social grade DE","%Social rent","%more than 3 beds","Residential population density","No vehicle in HHs", "1 vehicle in HHs","2 vehicles in HHs","more than 3 vehicles in HHs","Hospitals","Parks","Supermarkets", "%Part-time worker","%Full-time worker","%Self-employed", "%Good Health","%Fair health", "%Bad heath","Cumulative COVID-19 infection rates","Cumulative COVID-19 mortality rates","%White", "%Mixed","%Indian","%Pakistani","%Bangladeshi","%Chinese","%Other Asian","%African","%Caribbean","%Other Black","%Other ethnic group")
plot.rank.features<- ggplot(data = rel.importance.trans) +
geom_col(aes(x = importance, y = forcats::fct_rev(factor(Feature2)), fill = {importance > 0})) +
#scale_fill_manual(values=c("blue", "red")) +
ggtitle(expression(paste("Ranking the features (0 to 1)"))) +
ylab("Feature importance")+
theme_bw()+
scale_fill_manual(values="gray40")+
theme(axis.text.x = element_text(angle = 45, hjust = 1),
legend.position = "none") + facet_grid(~group)
plot.rank.features
ggsave("lasso.mnl.rank.features.no.scale.13Jul2023.png",plot.rank.features,width=200, height=200, units = "mm", dpi = 300, bg = "white")
write.csv(rel.importance,"rel.importance.feature.selection.no.scale.13Jul2023.csv")
